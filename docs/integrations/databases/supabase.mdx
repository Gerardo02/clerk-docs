---
title: Integrate Supabase with Clerk
description: Learn how to integrate Clerk into your Supabase application.
---

# Integrate Supabase with Clerk

> [!WARNING]
> You must have a Next.js project with Clerk set up to follow this tutorial. See [the quickstart](/docs/quickstarts/nextjs) to get started. You must also have a Supabase project set up, and this guide assumes you already have a table in your Supabase database. If you haven't already, [create a Supabase project](https://supabase.com/dashboard/projects).

Integrating Supabase with Clerk gives you the benefits of using a Supabase database while leveraging Clerk's authentication, prebuilt components, and webhooks. To get the most out of Supabase with Clerk, you must implement custom [Row Level Security](https://supabase.com/docs/guides/auth/row-level-security) (RLS) policies.

RLS works by validating database queries according to the restrictions defined in the RLS policies applied to the table. This guide will walk you through:

- Creating a function in Supabase to parse the Clerk user ID from the authentication token.
- Creating a `user_id` column that defaults to the Clerk user's ID when new records are created.
- Creating policies to restrict what data can be read and inserted.
- Using the Clerk Supabase integration helper in your code to authenticate with Supabase and execute queries.

This integration restricts what data authenticated users can access in the database, but does not synchronize user records between Clerk and Supabase. To send additional data from Clerk to your Supabase database, we recommend using [webhooks](/docs/integrations/webhooks/overview).

For interacting with the Supabase dashboard, you can either use the **Supabase interface** or the **SQL Editor**. The **SQL Editor** is a more direct way to interact with your database, but the **Supabase interface** provides a more user-friendly experience.

<Steps>

### Create a SQL query that checks the user ID

The first step is to create a function named `requesting_user_id()` that will parse the Clerk user ID from the authentication token. This function will be used to set the default value of `user_id` in a table and in the RLS policies to ensure the user can only access their data.

<Tabs items={["Supabase interface", "SQL Editor"]}>
  <Tab>
    1. In the sidebar of your Supabase dashboard, navigate to **Database** > **Functions**.
    1. Select **Create a new function**.
    1. In the **Add a new function** sheet, make the following changes:
        - Set **Name of function** to `requesting_user_id`.
        - Set **Return type** to `text`.
        - Toggle **Show advanced settings** on.
        - Set **Language** to `sql`.
        - Populate the **Definition** with the following sql:
          ```sql
          SELECT NULLIF(
              current_setting('request.jwt.claims', true)::json->>'sub',
              ''
          )::text;
          ```
        - Select **Confirm**.
  </Tab>
  <Tab>
    1. In the sidebar of your [Supabase dashboard](https://supabase.com/dashboard/projects), navigate to **SQL Editor**, then select **New query**. Paste the following into the editor:
        ```sql
        CREATE OR REPLACE FUNCTION requesting_user_id()
        RETURNS TEXT AS $$
            SELECT NULLIF(
                current_setting('request.jwt.claims', true)::json->>'sub',
                ''
            )::text;
        $$ LANGUAGE SQL STABLE;
        ```
    1. To execute the query and create the `requesting_user_id` function, select **Run**.
  </Tab>
</Tabs>

### Add a column for user IDs to your Supabase tables

To show users content scoped to their account, you must create RLS policies that check the user's Clerk ID. This requires storing Clerk user IDs on the relevant tables. For this guide, the column will be named `user_id`, but you can use any name you'd like.

By setting the default value of this column to execute the `requesting_user_id()` function, records inserted by the Supabase API will be populated with the requesting user's ID available to Supabase from the request headers.

<Tabs items={["Supabase interface", "SQL Editor"]}>
<Tab>
In the sidebar of your Supabase dashboard, navigate to **Database** > **Tables**. From here, you can add the user ID column to the table you want to use.
1. Name the column `user_id`.
1. This column's data type must be `text`.
1. In the **Default Value** field, add `(requesting_user_id())`.
</Tab>
<Tab>
From the sidebar, select **SQL Editor** and run the following query, replacing `%TABLE_NAME%` with the name of the table you wish to add `user_id` to:

```sql
alter table %TABLE_NAME% add user_id text not null default (requesting_user_id());
```

<Callout type="info">
  This step is required because Supabase's `auth.uuid()` function, which normally grants access to the user ID in RLS policies, is not compatible with Clerk's user IDs.
</Callout>
</Tab>
</Tabs>

{/* #### Using the Table Editor

- In the sidebar of your Supabase dashboard, navigate to **Database** > **Tables**. From here, you can add the user ID column to the table you want to use.
    - Name the column `user_id`.
    - This column's data type must be `text`.
    - In the **Default Value** field, add `(requesting_user_id())`.

#### Using the SQL Editor

From the sidebar, select **SQL Editor** and run the following query, replacing `%TABLE_NAME%` with the name of the table you wish to add `user_id` to:

```sql
alter table %TABLE_NAME% add user_id text not null default (requesting_user_id());
```

<Callout type="info">
  This step is required because Supabase's `auth.uuid()` function, which normally grants access to the user ID in RLS policies, is not compatible with Clerk's user IDs.
</Callout> */}

### Enable RLS on the table

Before you can create RLS policies, the feature must be enabled per table.

<Tabs items={["Supabase interface", "SQL Editor"]}>
<Tab>
In the left navigation, select **Table Editor** and select the desired table. Click the **RLS disabled** button in the top navigation, then **Enable RLS for this table** in the menu that appears.
</Tab>
<Tab>
To enable RLS on a table using the SQL Editor, run the following query, replacing `%TABLE_NAME%` with the name of your table.

```sql
alter table %TABLE_NAME% enable row level security;
```
</Tab>
</Tabs>

### Create ID-based RLS policies

Create RLS policies that allow users to modify and read content associated with their user IDs. This example will use an `Addresses` table, but you can replace `Addresses` with whatever table you're using.

<Tabs items={["Supabase interface", "SQL Editor"]}>
<Tab>
Use the sidebar to navigate to **Authentication** > **Policies**.

1. Click the **New Policy** button next to the table you are working with to create an RLS policy for inserting content:
    - Name the policy whatever you want.
    - For **Allowed operation**, select **INSERT**.
    - For **Target roles**, select **authenticated**.
    - For the **WITH CHECK** expression, paste the following:
    ```sql filename="Supabase policy editor"
    requesting_user_id() = user_id
    ```
1. Click **New Policy** again to create an RLS policy for reading content:
    - Name the policy whatever you want.
    - For **Allowed operation**, select **SELECT**.
    - For **Target roles**, select **authenticated**.
    - For the **USING** expression, paste the following:
    ```sql filename="Supabase policy editor"
    requesting_user_id() = user_id
    ```
</Tab>
<Tab>
In the sidebar, navigate to **SQL Editor**. Run the following two queries to add a policy for `SELECT` and `INSERT` operations. Replace `%POLICY_NAME%` for each with a unique name. Replace `%TABLE_NAME%` with the name of the desired table.

```sql
-- This policy will enforce the user_id field on INSERT statements matches the Clerk user ID.
CREATE POLICY "%POLICY_NAME%" ON "public"."%TABLE_NAME%"
AS PERMISSIVE FOR INSERT
TO authenticated
WITH CHECK (requesting_user_id() = user_id)

-- This policy will restrict SELECT statements only to records where user_id matches the Clerk user ID.
CREATE POLICY "%POLICY_NAME%" ON "public"."%TABLE_NAME%"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (requesting_user_id() = user_id)
```
</Tab>
</Tabs>

### Get your Supabase JWT secret key

To give users access to your data, Supabase's API requires an authentication token. Your Clerk project can generate these authentication tokens, but it needs your Supabase project's JWT secret key first.

To find the JWT secret key:

1. In the Supabase dashboard, select your project.
1. In the sidebar, select **Settings** > **API**. Copy the value in the **JWT Secret** field.
1. Open the [Clerk dashboard](https://dashboard.clerk.com/) in a new tab.

### Create a Supabase JWT template

Clerk's JWT templates allow you to generate a new valid Supabase authentication token for each signed in user. These tokens allow authenticated users to access your data with Supabase's API.

To create a JWT template for Supabase:

1. Open your project in the Clerk Dashboard and navigate to the **JWT Templates** page in the sidebar.
2. Select the **New template** button, then select **Supabase** from the list of options.
3. Configure your template:
    - The value of the **Name** field will be required when using the template in your code. For this tutorial, name it `supabase`.
    - **Signing algorithm** will be `HS256` by default. This algorithm is required to use JWTs with Supabase. [Learn more in their docs](https://supabase.com/docs/guides/resources/glossary#jwt-signing-secret).
    - Under **Signing key**, add the value of your Supabase **JWT secret key** from [the previous step](#get-your-supabase-jwt-secret-key).
    - Leave all other fields at their default settings unless you want to customize them. See [Clerk's JWT template docs](/docs/backend-requests/making/jwt-templates#creating-a-template) to learn what each of them do.
    - Select **Save** from the notification bubble to complete setup.

### Set up your local project

To use Clerk with Supabase in your code, first install the necessary SDKs by running the following terminal command in the root directory of your project:

<CodeBlockTabs options={["npm", "yarn", "pnpm"]}>
```bash filename="terminal"
npm install @supabase/supabase-js
```

```bash filename="terminal"
yarn add @supabase/supabase-js
```

```bash filename="terminal"
pnpm add @supabase/supabase-js
```
</CodeBlockTabs>

Then, set up your environment variables:

1. If you don't have a `.env.local` file in the root directory of your Next.js project, create one now.
1. Find your Clerk publishable key and secret key. If you're signed into Clerk, the `.env.local` snippet below will contain your keys. Otherwise:
    - Navigate to your Clerk Dashboard.
    - Select your application, then select **API Keys** in the sidebar menu.
    - You can copy your keys from the **Quick Copy** section.
1. Add your keys to your `.env.local` file.
1. Find your Supabase credentials:
    - Go to your Supabase dashboard. In the sidebar, select **Settings** > **API**.
    - Copy the **Project URL** and add it to your `.env.local` file.
    - Copy the value beside `anon` `public` in the **Project API Keys** section and add it to your `.env.local` file.

The final result should be similar to this:

    ```js filename=".env.local"
    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
    NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
    NEXT_PUBLIC_SUPABASE_KEY=your_supabase_anon_key
    ```

### Fetch Supabase data in your code

The following steps will show you how to access content from your Supabase tables based on the user's ID. It assumes you have a table named `"Addresses"` with a `content` field, but you can adapt this code for any use case.

<Tabs items={["Client component", "Server component"]}>
<Tab>
1. Create a component and define a `createClerkSupabaseClient` method. This method returns a client that connects to Supabase with an authentication token from your Clerk JWT template:
    ```ts filename="app/supabase/page.tsx"
    "use client";
    import { createClient } from "@supabase/supabase-js";
    import { useRef, useState } from "react";

    // Add clerk to Window to avoid type errors
    declare global {
      interface Window {
        Clerk: any;
      }
    }

    function createClerkSupabaseClient() {
      return createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_KEY!,
        {
          global: {
            // Get the Supabase token with a custom fetch method
            fetch: async (url, options = {}) => {
              const clerkToken = await window.Clerk.session?.getToken({
                template: "supabase",
              });

              // Construct fetch headers
              const headers = new Headers(options?.headers);
              headers.set("Authorization", `Bearer ${clerkToken}`);

              // Now call the default fetch
              return fetch(url, {
                ...options,
                headers,
              });
            },
          },
        }
      );
    }

    const client = createClerkSupabaseClient();
    ```

1. Next, define a component with methods for listing addresses from and sending addresses to your database:
    ```tsx filename="app/supabase/page.tsx"
    export default function Supabase() {
      const [addresses, setAddresses] = useState<any>();
      const listAddresses = async () => {
        // Fetches all addresses scoped to the user
        // Replace "Addresses" with your table name
        const { data, error } = await client.from("Addresses").select();
        if (!error) setAddresses(data);
      };

      const inputRef = useRef<HTMLInputElement>(null);
      const sendAddress = async () => {
        if (!inputRef.current?.value) return;
        await client.from("Addresses").insert({
          // Replace content with whatever field you want
          content: inputRef.current?.value,
        });
      };

      return null;
    }
    ```

1. Finally, edit your component to return a basic UI that allows you to list all your addresses and send new ones:
    ```tsx filename="app/supabase/page.tsx"
    return (
      <>
        <div style={{ display: "flex", flexDirection: "column" }}>
          <input
            onSubmit={sendAddress}
            type="text"
            ref={inputRef}
          />
          <button onClick={sendAddress}>Send Address</button>
          <button onClick={listAddresses}>Fetch Addresses</button>
        </div>
        <h2>Addresses</h2>
        {!addresses ? (
          <p>No addresses</p>
        ) : (
          <ul>
            {addresses.map((address: any) => (
              <li key={address.id}>{address.content}</li>
            ))}
          </ul>
        )}
      </>
    );
    ```

1. The final result should be similar to this:
    ```ts filename="app/supabase/page.tsx"
    "use client";
    import { createClient } from "@supabase/supabase-js";
    import { useRef, useState } from "react";

    // Add clerk to Window to avoid type errors
    declare global {
      interface Window {
        Clerk: any;
      }
    }

    function createClerkSupabaseClient() {
      return createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_KEY!,
        {
          global: {
            // Get the Supabase token with a custom fetch method
            fetch: async (url, options = {}) => {
              const clerkToken = await window.Clerk.session?.getToken({
                template: "supabase",
              });

              // Construct fetch headers
              const headers = new Headers(options?.headers);
              headers.set("Authorization", `Bearer ${clerkToken}`);

              // Now call the default fetch
              return fetch(url, {
                ...options,
                headers,
              });
            },
          },
        }
      );
    }

    const client = createClerkSupabaseClient();

    export default function Supabase() {
      const [addresses, setAddresses] = useState<any>();
      const listAddresses = async () => {
        // Fetches all addresses scoped to the user
        // Replace "Addresses" with your table name
        const { data, error } = await client.from("Addresses").select();
        if (!error) setAddresses(data);
      };

      const inputRef = useRef<HTMLInputElement>(null);
      const sendAddress = async () => {
        if (!inputRef.current?.value) return;
        await client.from("Addresses").insert({
          // Replace content with whatever field you want
          content: inputRef.current?.value,
        });
      };

      return (
        <>
          <div style={{ display: "flex", flexDirection: "column" }}>
            <input
              onSubmit={sendAddress}
              style={{ color: "black" }}
              type="text"
              ref={inputRef}
            />
            <button onClick={sendAddress}>Send Address</button>
            <button onClick={listAddresses}>Fetch Addresses</button>
          </div>
          <h2>Addresses</h2>
          {!addresses ? (
            <p>No addresses</p>
          ) : (
            <ul>
              {addresses.map((address: any) => (
                <li key={address.id}>{address.content}</li>
              ))}
            </ul>
          )}
        </>
      );
    }
    ```

1. Try out your application. When you visit the page with your component, you'll be required to sign in. Try creating and fetching content.

</Tab>

<Tab>
1. To create a Supabase client in a Server component, you must first install the Supabase SSR package:

    <CodeBlockTabs type="installer" options={["npm", "yarn", "pnpm"]}>
      ```bash filename="terminal"
      npm install @supabase/ssr
      ```

      ```bash filename="terminal"
      yarn add @supabase/ssr
      ```

      ```bash filename="terminal"
      pnpm add @supabase/ssr
      ```
    </CodeBlockTabs>

2. Create a component and define a `createClerkSupabaseClient` method. This method returns a client that connects to Supabase with an authentication token from your Clerk JWT template:

    ```ts filename="app/supabase/page.tsx"
    import { auth } from "@clerk/nextjs/server";
    import { CookieOptions, createServerClient } from "@supabase/ssr";
    import { cookies } from "next/headers";

    async function createClerkSupabaseClient() {
      const cookieStore = cookies();
      const { getToken } = auth();

      const token = await getToken({ template: "supabase" });
      const authToken = token ? { Authorization: `Bearer ${token}` } : null;

      return createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_KEY!,
        {
          global: { headers: { "Cache-Control": "no-store", ...authToken } },
          cookies: {
            get(name: string) {
              return cookieStore.get(name)?.value;
            },
            set(name: string, value: string, options: CookieOptions) {
              try {
                cookieStore.set({ name, value, ...options });
              } catch (error) {
                // Handle the error
              }
            },
            remove(name: string, options: CookieOptions) {
              try {
                cookieStore.set({ name, value: "", ...options });
              } catch (error) {
                // Handle the error
              }
            },
          },
        }
      );
    }
    ```

1. Next, define a component with methods for accessing a user's addresses from your database:

    ```ts filename="app/supabase/page.tsx"
    export default async function Supabase() {
      const client = await createClerkSupabaseClient();

      const { data, error } = await client.from("Addresses").select();

      if (error) {
        return <p>Error: {JSON.stringify(error, null, 2)}</p>;
      }

      return null;
    }
    ```

1. Finally, edit your component to return a basic UI that allows you to list all your addresses:

    ```ts filename="app/supabase/page.tsx"
      return (
        <div>
          <h2>Addresses</h2>
          {!data ? (
            <p>No addresses</p>
          ) : (
            <ul>
              {data.map((address: any) => (
                <li key={address.id}>{address.content}</li>
              ))}
            </ul>
          )}
        </div>
      );
    }
    ```

1. The final result should be similar to this:
    ```ts filename="app/supabase/page.tsx"
    import { auth } from "@clerk/nextjs/server";
    import { CookieOptions, createServerClient } from "@supabase/ssr";
    import { cookies } from "next/headers";

    async function createClerkSupabaseClient() {
      const cookieStore = cookies();
      const { getToken } = auth();

      const token = await getToken({ template: "supabase" });
      const authToken = token ? { Authorization: `Bearer ${token}` } : null;

      return createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_KEY!,
        {
          global: { headers: { "Cache-Control": "no-store", ...authToken } },
          cookies: {
            get(name: string) {
              return cookieStore.get(name)?.value;
            },
            set(name: string, value: string, options: CookieOptions) {
              try {
                cookieStore.set({ name, value, ...options });
              } catch (error) {
                // Handle the error
              }
            },
            remove(name: string, options: CookieOptions) {
              try {
                cookieStore.set({ name, value: "", ...options });
              } catch (error) {
                // Handle the error
              }
            },
          },
        }
      );
    }

    export default async function Supabase() {
      const client = await createClerkSupabaseClient();

      const { data, error } = await client.from("Addresses").select();

      if (error) {
        return <p>Error: {JSON.stringify(error, null, 2)}</p>;
      }

      return (
        <div>
          <h2>Addresses</h2>
          {!data ? (
            <p>No addresses</p>
          ) : (
            <ul>
              {data.map((address: any) => (
                <li key={address.id}>{address.content}</li>
              ))}
            </ul>
          )}
        </div>
      );
    }
    ```

1. Try out your application. When you visit the page with your component, you'll be required to sign in. Try creating and fetching content.

</Tab>
</Tabs>


</Steps>

## Next steps

- Try adding some [custom claims](/docs/backend-requests/making/jwt-templates) to the JWT template in `app_metadata` or `user_metadata`
